/**
 * Test Utilities - Generic & Type-Safe Test Helpers
 * 
 * This file provides generic, type-safe utilities for testing CRM entities.
 * It complements the existing test-utilities.ts with enhanced TypeScript support.
 */

import type { Database } from '@/types/database.types'
import type { 
  Organization, 
  OrganizationInsert, 
  Contact, 
  ContactInsert,
  Product, 
  ProductInsert, 
  Opportunity, 
  OpportunityInsert, 
  Interaction, 
  InteractionInsert 
} from '@/types/entities'
import { testSupabase, PerformanceMonitor, TestCleanup } from '../backend/setup/test-setup'
import { StringUtils, DateUtils } from './test-utilities'

// Generic entity type mapping
type EntityMap = {
  organization: {
    Row: Organization
    Insert: OrganizationInsert
    Update: Database['public']['Tables']['organizations']['Update']
  }
  contact: {
    Row: Contact
    Insert: ContactInsert
    Update: Database['public']['Tables']['contacts']['Update']
  }
  product: {
    Row: Product
    Insert: ProductInsert
    Update: Database['public']['Tables']['products']['Update']
  }
  opportunity: {
    Row: Opportunity
    Insert: OpportunityInsert
    Update: Database['public']['Tables']['opportunities']['Update']
  }
  interaction: {
    Row: Interaction
    Insert: InteractionInsert
    Update: Database['public']['Tables']['interactions']['Update']
  }
}

// Entity type keys
type EntityType = keyof EntityMap

// Generic entity factory interface
interface EntityFactory<T extends EntityType> {
  entityType: T
  defaults: Partial<EntityMap[T]['Insert']>
  overrides?: Partial<EntityMap[T]['Insert']>
}

/**
 * Generic entity factory - creates type-safe test entities
 */
export function createTestEntity<T extends EntityType>(
  entityType: T,
  overrides?: Partial<EntityMap[T]['Insert']>
): EntityMap[T]['Insert'] {
  const factory = getEntityFactory(entityType)
  
  return {
    ...factory.defaults,
    ...overrides
  } as EntityMap[T]['Insert']
}

/**
 * Get appropriate factory defaults for entity type
 */
function getEntityFactory<T extends EntityType>(entityType: T): EntityFactory<T> {
  const timestamp = Date.now()
  const testUserId = '00000000-0000-0000-0000-000000000001'
  
  const factories: Record<EntityType, EntityFactory<EntityType>> = {
    organization: {
      entityType: 'organization',
      defaults: {
        name: `Test Organization ${timestamp}`,
        type: 'customer',
        priority: 'B',
        segment: 'Test Segment',
        is_principal: false,
        is_distributor: false,
        created_by: testUserId,
        phone: StringUtils.randomPhone(),
        email: StringUtils.randomEmail(),
        description: `Generated by test utilities at ${new Date().toISOString()}`,
      }
    },
    contact: {
      entityType: 'contact',
      defaults: {
        first_name: 'John',
        last_name: `TestContact-${StringUtils.randomString(6)}`,
        email: StringUtils.randomEmail(),
        phone: StringUtils.randomPhone(),
        title: 'Test Manager',
        purchase_influence: 'moderate',
        decision_authority: 'recommender',
        organization_id: '', // Must be provided in overrides
        created_by: testUserId,
      }
    },
    product: {
      entityType: 'product',
      defaults: {
        name: `Test Product ${timestamp}`,
        category: 'dry_goods',
        description: 'Test product for automated testing',
        principal_id: '', // Must be provided in overrides
        created_by: testUserId,
        sku: `TEST-${StringUtils.randomString(8)}`,
        unit_of_measure: 'each',
        list_price: 10.99,
      }
    },
    opportunity: {
      entityType: 'opportunity',
      defaults: {
        name: `Test Opportunity ${timestamp}`,
        stage: 'qualified',
        status: 'active',
        estimated_value: 10000,
        probability: 0.25,
        estimated_close_date: DateUtils.futureDate(30),
        description: 'Generated opportunity for testing',
        organization_id: '', // Must be provided in overrides
        created_by: testUserId,
      }
    },
    interaction: {
      entityType: 'interaction',
      defaults: {
        type: 'email',
        subject: `Test Interaction ${timestamp}`,
        description: 'Automated test interaction',
        interaction_date: new Date().toISOString(),
        opportunity_id: '', // Must be provided in overrides
        created_by: testUserId,
      }
    }
  }

  return factories[entityType] as EntityFactory<T>
}

/**
 * Database Test Helper - Type-safe database operations for testing
 */
export class DatabaseTestHelper<T extends EntityType> {
  constructor(
    private entityType: T,
    private tableName: string = `${entityType}s` // Default pluralization
  ) {}

  /**
   * Create entity and track for cleanup
   */
  async create(
    data: Partial<EntityMap[T]['Insert']>,
    trackForCleanup: boolean = true
  ): Promise<EntityMap[T]['Row']> {
    return PerformanceMonitor.measureQuery(`create_${this.entityType}`, async () => {
      const entityData = createTestEntity(this.entityType, data)
      
      const { data: result, error } = await testSupabase
        .from(this.tableName as any)
        .insert(entityData as any)
        .select()
        .single()

      if (error || !result) {
        throw new Error(`Failed to create ${this.entityType}: ${error?.message || 'No data returned'}`)
      }

      if (trackForCleanup && typeof result === 'object' && 'id' in result) {
        TestCleanup.trackCreatedRecord(this.tableName, (result as any).id)
      }

      return result as unknown as EntityMap[T]['Row']
    })
  }

  /**
   * Read entity by ID with performance tracking
   */
  async read(id: string): Promise<EntityMap[T]['Row']> {
    return PerformanceMonitor.measureQuery(`read_${this.entityType}`, async () => {
      const { data, error } = await testSupabase
        .from(this.tableName as any)
        .select('*')
        .eq('id', id)
        .single()

      if (error) {
        throw new Error(`Failed to read ${this.entityType}: ${error.message}`)
      }

      return data as unknown as EntityMap[T]['Row']
    })
  }

  /**
   * Update entity with type safety
   */
  async update(
    id: string, 
    updates: Partial<EntityMap[T]['Update']>
  ): Promise<EntityMap[T]['Row']> {
    return PerformanceMonitor.measureQuery(`update_${this.entityType}`, async () => {
      const { data, error } = await testSupabase
        .from(this.tableName as any)
        .update(updates as any)
        .eq('id', id)
        .select()
        .single()

      if (error) {
        throw new Error(`Failed to update ${this.entityType}: ${error.message}`)
      }

      return data as unknown as EntityMap[T]['Row']
    })
  }

  /**
   * Delete entity (soft delete if supported)
   */
  async delete(id: string): Promise<void> {
    return PerformanceMonitor.measureQuery(`delete_${this.entityType}`, async () => {
      // Check if entity supports soft delete
      const supportsSoftDelete = ['organizations', 'contacts', 'products', 'opportunities'].includes(this.tableName)
      
      if (supportsSoftDelete) {
        const { error } = await testSupabase
          .from(this.tableName as any)
          .update({ deleted_at: new Date().toISOString() } as any)
          .eq('id', id)

        if (error) {
          throw new Error(`Failed to soft delete ${this.entityType}: ${error.message}`)
        }
      } else {
        const { error } = await testSupabase
          .from(this.tableName as any)
          .delete()
          .eq('id', id)

        if (error) {
          throw new Error(`Failed to delete ${this.entityType}: ${error.message}`)
        }
      }
    })
  }

  /**
   * List entities with optional filtering
   */
  async list(
    filters?: Record<string, any>,
    limit: number = 100
  ): Promise<EntityMap[T]['Row'][]> {
    return PerformanceMonitor.measureQuery(`list_${this.entityType}`, async () => {
      let query = testSupabase
        .from(this.tableName as any)
        .select('*')
        .limit(limit)

      // Apply filters if provided
      if (filters) {
        Object.entries(filters).forEach(([key, value]) => {
          if (value !== undefined && value !== null) {
            query = query.eq(key, value)
          }
        })
      }

      // Exclude soft-deleted records
      const supportsSoftDelete = ['organizations', 'contacts', 'products', 'opportunities'].includes(this.tableName)
      if (supportsSoftDelete) {
        query = query.is('deleted_at', null)
      }

      const { data, error } = await query

      if (error) {
        throw new Error(`Failed to list ${this.entityType}: ${error.message}`)
      }

      return (data || []) as unknown as EntityMap[T]['Row'][]
    })
  }

  /**
   * Check if entity exists
   */
  async exists(id: string): Promise<boolean> {
    return PerformanceMonitor.measureQuery(`exists_${this.entityType}`, async () => {
      const { count, error } = await testSupabase
        .from(this.tableName as any)
        .select('*', { count: 'exact', head: true })
        .eq('id', id)

      if (error) {
        throw new Error(`Failed to check ${this.entityType} existence: ${error.message}`)
      }

      return (count || 0) > 0
    })
  }
}

/**
 * Database result validation utility
 */
export function checkDatabaseResult<T>(
  result: { data: T | null; error: any },
  expectations: {
    shouldSucceed?: boolean
    expectedError?: string | RegExp
    dataValidation?: (data: T) => boolean
  } = {}
): void {
  const { shouldSucceed = true, expectedError, dataValidation } = expectations

  if (shouldSucceed) {
    if (result.error) {
      throw new Error(`Expected success but got error: ${result.error.message}`)
    }
    if (!result.data) {
      throw new Error('Expected data but got null')
    }
    if (dataValidation && !dataValidation(result.data)) {
      throw new Error('Data validation failed')
    }
  } else {
    if (!result.error) {
      throw new Error('Expected error but operation succeeded')
    }
    if (expectedError) {
      const errorMessage = result.error.message || String(result.error)
      if (typeof expectedError === 'string') {
        if (!errorMessage.includes(expectedError)) {
          throw new Error(`Expected error containing "${expectedError}" but got: ${errorMessage}`)
        }
      } else if (expectedError instanceof RegExp) {
        if (!expectedError.test(errorMessage)) {
          throw new Error(`Expected error matching ${expectedError} but got: ${errorMessage}`)
        }
      }
    }
  }
}

/**
 * Mock form data generator
 */
export function mockFormData<T extends EntityType>(
  entityType: T,
  customFields?: Partial<EntityMap[T]['Insert']>
): EntityMap[T]['Insert'] {
  return createTestEntity(entityType, customFields)
}

/**
 * Test enum values utility
 */
export function testEnumValues(
  enumObject: Record<string, string | number>, 
  testValue: string | number
): boolean {
  const enumValues = Object.values(enumObject)
  return enumValues.includes(testValue)
}

/**
 * Entity relationship validator
 */
export class EntityRelationshipValidator {
  /**
   * Validate organization-contact relationship
   */
  static async validateOrganizationContact(
    organizationId: string,
    contactId: string
  ): Promise<boolean> {
    const contact = await testSupabase
      .from('contacts')
      .select('organization_id')
      .eq('id', contactId)
      .single()

    return contact.data?.organization_id === organizationId
  }

  /**
   * Validate principal-product relationship
   */
  static async validatePrincipalProduct(
    principalId: string,
    productId: string
  ): Promise<boolean> {
    const product = await testSupabase
      .from('products')
      .select('principal_id')
      .eq('id', productId)
      .single()

    return product.data?.principal_id === principalId
  }

  /**
   * Validate opportunity relationships
   */
  static async validateOpportunityRelationships(
    opportunityId: string,
    expectedRelationships: {
      organizationId?: string
      contactId?: string
      principalId?: string
    }
  ): Promise<boolean> {
    const opportunity = await testSupabase
      .from('opportunities')
      .select('organization_id, contact_id, principal_organization_id')
      .eq('id', opportunityId)
      .single()

    if (opportunity.error || !opportunity.data) return false

    const { organization_id, contact_id, principal_organization_id } = opportunity.data

    if (expectedRelationships.organizationId && organization_id !== expectedRelationships.organizationId) {
      return false
    }
    if (expectedRelationships.contactId && contact_id !== expectedRelationships.contactId) {
      return false
    }
    if (expectedRelationships.principalId && principal_organization_id !== expectedRelationships.principalId) {
      return false
    }

    return true
  }
}

/**
 * Enhanced performance utilities
 */
export class TestPerformanceUtils {
  /**
   * Measure multiple operations and return statistics
   */
  static async measureOperations<T>(
    operations: Array<{ name: string; operation: () => Promise<T> }>,
    iterations: number = 1
  ): Promise<{
    operations: Array<{
      name: string
      avgTime: number
      minTime: number
      maxTime: number
      results: T[]
    }>
    totalTime: number
  }> {
    const results: any = {
      operations: [],
      totalTime: 0
    }

    const startTime = performance.now()

    for (const { name, operation } of operations) {
      const times: number[] = []
      const operationResults: T[] = []

      for (let i = 0; i < iterations; i++) {
        const iterationStart = performance.now()
        const result = await operation()
        const iterationTime = performance.now() - iterationStart

        times.push(iterationTime)
        operationResults.push(result)
      }

      results.operations.push({
        name,
        avgTime: times.reduce((sum, time) => sum + time, 0) / times.length,
        minTime: Math.min(...times),
        maxTime: Math.max(...times),
        results: operationResults
      })
    }

    results.totalTime = performance.now() - startTime
    return results
  }

  /**
   * Benchmark database operations
   */
  static async benchmarkCRUD<T extends EntityType>(
    entityType: T,
    testData: Partial<EntityMap[T]['Insert']>,
    iterations: number = 10
  ): Promise<{
    create: { avgTime: number; successRate: number }
    read: { avgTime: number; successRate: number }
    update: { avgTime: number; successRate: number }
    delete: { avgTime: number; successRate: number }
  }> {
    const helper = new DatabaseTestHelper(entityType)
    const createdIds: string[] = []

    // Benchmark Create
    const createTimes: number[] = []
    let createSuccesses = 0

    for (let i = 0; i < iterations; i++) {
      try {
        const startTime = performance.now()
        const entity = await helper.create(testData, false) // Don't track for cleanup during benchmark
        const endTime = performance.now()

        createTimes.push(endTime - startTime)
        createdIds.push(entity.id)
        createSuccesses++
      } catch (error) {
        console.warn(`Create benchmark iteration ${i} failed:`, error)
      }
    }

    // Benchmark Read
    const readTimes: number[] = []
    let readSuccesses = 0

    for (const id of createdIds.slice(0, Math.min(iterations, createdIds.length))) {
      try {
        const startTime = performance.now()
        await helper.read(id)
        const endTime = performance.now()

        readTimes.push(endTime - startTime)
        readSuccesses++
      } catch (error) {
        console.warn(`Read benchmark failed for ${id}:`, error)
      }
    }

    // Benchmark Update
    const updateTimes: number[] = []
    let updateSuccesses = 0

    for (const id of createdIds.slice(0, Math.min(iterations, createdIds.length))) {
      try {
        const startTime = performance.now()
        await helper.update(id, { updated_at: new Date().toISOString() } as any)
        const endTime = performance.now()

        updateTimes.push(endTime - startTime)
        updateSuccesses++
      } catch (error) {
        console.warn(`Update benchmark failed for ${id}:`, error)
      }
    }

    // Benchmark Delete
    const deleteTimes: number[] = []
    let deleteSuccesses = 0

    for (const id of createdIds) {
      try {
        const startTime = performance.now()
        await helper.delete(id)
        const endTime = performance.now()

        deleteTimes.push(endTime - startTime)
        deleteSuccesses++
      } catch (error) {
        console.warn(`Delete benchmark failed for ${id}:`, error)
      }
    }

    return {
      create: {
        avgTime: createTimes.reduce((sum, time) => sum + time, 0) / createTimes.length || 0,
        successRate: createSuccesses / iterations
      },
      read: {
        avgTime: readTimes.reduce((sum, time) => sum + time, 0) / readTimes.length || 0,
        successRate: readSuccesses / Math.min(iterations, createdIds.length) || 0
      },
      update: {
        avgTime: updateTimes.reduce((sum, time) => sum + time, 0) / updateTimes.length || 0,
        successRate: updateSuccesses / Math.min(iterations, createdIds.length) || 0
      },
      delete: {
        avgTime: deleteTimes.reduce((sum, time) => sum + time, 0) / deleteTimes.length || 0,
        successRate: deleteSuccesses / createdIds.length || 0
      }
    }
  }
}

// Export helper instances for common entities
export const OrganizationTestHelper = new DatabaseTestHelper('organization', 'organizations')
export const ContactTestHelper = new DatabaseTestHelper('contact', 'contacts')
export const ProductTestHelper = new DatabaseTestHelper('product', 'products')
export const OpportunityTestHelper = new DatabaseTestHelper('opportunity', 'opportunities')
export const InteractionTestHelper = new DatabaseTestHelper('interaction', 'interactions')

// Export entity validation utilities
export const EnumValidation = {
  organizationType: (value: string) => testEnumValues(
    { customer: 'customer', principal: 'principal', distributor: 'distributor', prospect: 'prospect', vendor: 'vendor' },
    value
  ),
  opportunityStage: (value: string) => testEnumValues(
    { lead: 'lead', qualified: 'qualified', proposal: 'proposal', negotiation: 'negotiation', closed_won: 'closed_won', closed_lost: 'closed_lost' },
    value
  ),
  interactionType: (value: string) => testEnumValues(
    { call: 'call', email: 'email', meeting: 'meeting', demo: 'demo', proposal: 'proposal', follow_up: 'follow_up' },
    value
  ),
  productCategory: (value: string) => testEnumValues(
    { beverages: 'beverages', dairy: 'dairy', frozen: 'frozen', fresh_produce: 'fresh_produce', dry_goods: 'dry_goods' },
    value
  )
}