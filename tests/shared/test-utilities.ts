/**
 * Shared Test Utilities
 * Framework-agnostic utilities that can be used by both Vitest and Playwright tests
 * IMPORTANT: This file must NOT import any test framework specific modules
 * 
 * This file provides legacy compatibility and integrates with the new generic test-utils.ts
 */

import type { Database } from '@/types/database.types'

// Type definitions for entity data
type OrganizationTestData = Partial<Database['public']['Tables']['organizations']['Insert']>
type ContactTestData = Partial<Database['public']['Tables']['contacts']['Insert']>
type ProductTestData = Partial<Database['public']['Tables']['products']['Insert']>
type OpportunityTestData = Partial<Database['public']['Tables']['opportunities']['Insert']>
type InteractionTestData = Partial<Database['public']['Tables']['interactions']['Insert']>

/**
 * Enhanced Test Data Generators with TypeScript generics and proper database schema
 * Updated to match current database structure
 */
export const TestData = {
  organizations: {
    valid: (): OrganizationTestData => ({
      name: `Test Organization ${Date.now()}`,
      type: 'customer' as const,
      priority: 'B',
      segment: 'Fine Dining',
      phone: '555-0123',
      email: `test-${Date.now()}@example.com`,
      address_line_1: '123 Test Street',
      city: 'Test City',
      state_province: 'TC',
      postal_code: '12345',
      notes: 'Generated by automated tests',
      created_by: '00000000-0000-0000-0000-000000000001',
    }),
    
    invalid: {
      emptyName: (): OrganizationTestData => ({
        name: '',
        type: 'customer' as const,
        priority: 'B',
        segment: 'Fine Dining',
        created_by: '00000000-0000-0000-0000-000000000001',
      }),
      
      invalidEmail: (): OrganizationTestData => ({
        name: 'Test Org',
        type: 'customer' as const,
        priority: 'B',
        segment: 'Fine Dining',
        email: 'invalid-email',
        created_by: '00000000-0000-0000-0000-000000000001',
      }),

      invalidType: (): OrganizationTestData => ({
        name: 'Test Org',
        type: 'invalid_type' as any,
        priority: 'B',
        segment: 'Fine Dining',
        created_by: '00000000-0000-0000-0000-000000000001',
      }),
    },
  },

  contacts: {
    valid: (organizationId?: string): ContactTestData => ({
      first_name: 'John',
      last_name: `TestContact-${Date.now()}`,
      email: `john.doe-${Date.now()}@example.com`,
      phone: '555-0456',
      title: 'Test Manager',
      purchase_influence: 'moderate',
      decision_authority: 'recommender',
      organization_id: organizationId || '00000000-0000-0000-0000-000000000002',
      notes: 'Generated contact for testing',
      created_by: '00000000-0000-0000-0000-000000000001',
    }),
    
    invalid: {
      emptyFirstName: (organizationId?: string): ContactTestData => ({
        first_name: '',
        last_name: 'Doe',
        email: 'john@example.com',
        purchase_influence: 'moderate',
        decision_authority: 'recommender',
        organization_id: organizationId || '00000000-0000-0000-0000-000000000002',
        created_by: '00000000-0000-0000-0000-000000000001',
      }),

      invalidEmail: (organizationId?: string): ContactTestData => ({
        first_name: 'John',
        last_name: 'Doe',
        email: 'invalid-email-format',
        purchase_influence: 'moderate',
        decision_authority: 'recommender',
        organization_id: organizationId || '00000000-0000-0000-0000-000000000002',
        created_by: '00000000-0000-0000-0000-000000000001',
      }),
    },
  },

  products: {
    valid: (principalId?: string): ProductTestData => ({
      name: `Test Product ${Date.now()}`,
      category: 'dry_goods' as const,
      sku: `TEST-${Date.now()}`,
      description: 'Test product for automated testing',
      principal_id: principalId || '00000000-0000-0000-0000-000000000003',
      created_by: '00000000-0000-0000-0000-000000000001',
      unit_of_measure: 'each',
      list_price: 10.99,
    }),

    invalid: {
      emptyName: (principalId?: string): ProductTestData => ({
        name: '',
        category: 'dry_goods' as const,
        principal_id: principalId || '00000000-0000-0000-0000-000000000003',
        created_by: '00000000-0000-0000-0000-000000000001',
      }),

      invalidCategory: (principalId?: string): ProductTestData => ({
        name: 'Test Product',
        category: 'invalid_category' as any,
        principal_id: principalId || '00000000-0000-0000-0000-000000000003',
        created_by: '00000000-0000-0000-0000-000000000001',
      }),
    },
  },

  opportunities: {
    valid: (organizationId?: string, contactId?: string): OpportunityTestData => ({
      name: `Test Opportunity ${Date.now()}`,
      stage: 'qualified' as const,
      status: 'active' as const,
      estimated_value: 10000,
      probability: 25,
      estimated_close_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      description: 'Generated opportunity for testing',
      organization_id: organizationId || '00000000-0000-0000-0000-000000000002',
      contact_id: contactId,
      created_by: '00000000-0000-0000-0000-000000000001',
    }),

    invalid: {
      emptyName: (organizationId?: string): OpportunityTestData => ({
        name: '',
        stage: 'qualified' as const,
        status: 'active' as const,
        estimated_value: 10000,
        organization_id: organizationId || '00000000-0000-0000-0000-000000000002',
        created_by: '00000000-0000-0000-0000-000000000001',
      }),

      invalidStage: (organizationId?: string): OpportunityTestData => ({
        name: 'Test Opportunity',
        stage: 'invalid_stage' as any,
        status: 'active' as const,
        estimated_value: 10000,
        organization_id: organizationId || '00000000-0000-0000-0000-000000000002',
        created_by: '00000000-0000-0000-0000-000000000001',
      }),
    },
  },

  interactions: {
    valid: (opportunityId?: string, contactId?: string, organizationId?: string): InteractionTestData => ({
      type: 'email' as const,
      subject: `Test Interaction ${Date.now()}`,
      description: 'Automated test interaction',
      interaction_date: new Date().toISOString(),
      opportunity_id: opportunityId || '00000000-0000-0000-0000-000000000004',
      contact_id: contactId,
      organization_id: organizationId,
      created_by: '00000000-0000-0000-0000-000000000001',
    }),

    invalid: {
      emptySubject: (opportunityId?: string): InteractionTestData => ({
        type: 'email' as const,
        subject: '',
        description: 'Test interaction with empty subject',
        interaction_date: new Date().toISOString(),
        opportunity_id: opportunityId || '00000000-0000-0000-0000-000000000004',
        created_by: '00000000-0000-0000-0000-000000000001',
      }),

      invalidType: (opportunityId?: string): InteractionTestData => ({
        type: 'invalid_type' as any,
        subject: 'Test Interaction',
        description: 'Test interaction with invalid type',
        interaction_date: new Date().toISOString(),
        opportunity_id: opportunityId || '00000000-0000-0000-0000-000000000004',
        created_by: '00000000-0000-0000-0000-000000000001',
      }),
    },
  },
};

/**
 * Generic test data factory - Creates typed test data for any entity
 */
export function createTypedTestData<T extends keyof typeof TestData>(
  entityType: T,
  variant: 'valid' | string = 'valid',
  ...args: any[]
): any {
  if (variant === 'valid') {
    return (TestData[entityType] as any).valid(...args)
  } else {
    return (TestData[entityType] as any).invalid?.[variant]?.(...args)
  }
}

/**
 * String utilities
 */
export const StringUtils = {
  randomString: (length: number = 8): string => {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  },

  randomEmail: (): string => {
    return `test-${StringUtils.randomString(8)}@example.com`.toLowerCase();
  },

  randomPhone: (): string => {
    const digits = '0123456789';
    let phone = '555-';
    for (let i = 0; i < 4; i++) {
      phone += digits.charAt(Math.floor(Math.random() * digits.length));
    }
    return phone;
  },

  slugify: (text: string): string => {
    return text
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/[\s_-]+/g, '-')
      .replace(/^-+|-+$/g, '');
  },
};

/**
 * Date utilities
 */
export const DateUtils = {
  formatForInput: (date: Date): string => {
    return date.toISOString().split('T')[0];
  },

  addDays: (date: Date, days: number): Date => {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
  },

  isSameDay: (date1: Date, date2: Date): boolean => {
    return date1.toDateString() === date2.toDateString();
  },

  futureDate: (daysFromNow: number = 30): string => {
    return DateUtils.formatForInput(DateUtils.addDays(new Date(), daysFromNow));
  },

  pastDate: (daysAgo: number = 30): string => {
    return DateUtils.formatForInput(DateUtils.addDays(new Date(), -daysAgo));
  },
};

/**
 * Validation utilities
 */
export const ValidationUtils = {
  isValidEmail: (email: string): boolean => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  },

  isValidPhone: (phone: string): boolean => {
    const phoneRegex = /^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/;
    return phoneRegex.test(phone);
  },

  isValidUrl: (url: string): boolean => {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  },

  isNumeric: (value: string): boolean => {
    return !isNaN(Number(value)) && !isNaN(parseFloat(value));
  },

  isEmpty: (value: any): boolean => {
    if (value === null || value === undefined) return true;
    if (typeof value === 'string') return value.trim().length === 0;
    if (Array.isArray(value)) return value.length === 0;
    if (typeof value === 'object') return Object.keys(value).length === 0;
    return false;
  },
};

/**
 * Array utilities
 */
export const ArrayUtils = {
  randomItem: <T>(array: T[]): T => {
    return array[Math.floor(Math.random() * array.length)];
  },

  shuffleArray: <T>(array: T[]): T[] => {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  },

  groupBy: <T, K extends keyof T>(array: T[], key: K): Record<string, T[]> => {
    return array.reduce((groups, item) => {
      const group = String(item[key]);
      groups[group] = groups[group] || [];
      groups[group].push(item);
      return groups;
    }, {} as Record<string, T[]>);
  },
};

/**
 * Environment utilities
 */
export const EnvUtils = {
  isTest: (): boolean => {
    return process.env.NODE_ENV === 'test';
  },

  isCI: (): boolean => {
    return !!process.env.CI;
  },

  getBaseUrl: (): string => {
    return process.env.PLAYWRIGHT_BASE_URL || 
           process.env.VITE_BASE_URL || 
           'http://localhost:5173';
  },

  getTestTimeout: (): number => {
    return parseInt(process.env.TEST_TIMEOUT || '30000', 10);
  },
};

/**
 * Async utilities
 */
export const AsyncUtils = {
  sleep: (ms: number): Promise<void> => {
    return new Promise(resolve => setTimeout(resolve, ms));
  },

  retry: async <T>(
    operation: () => Promise<T>,
    maxAttempts: number = 3,
    delay: number = 1000
  ): Promise<T> => {
    let lastError: Error = new Error('Retry operation failed');
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        
        if (attempt === maxAttempts) {
          break;
        }
        
        await AsyncUtils.sleep(delay * attempt); // Exponential backoff
      }
    }
    
    throw lastError;
  },

  timeout: <T>(promise: Promise<T>, ms: number): Promise<T> => {
    return Promise.race([
      promise,
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error(`Operation timed out after ${ms}ms`)), ms)
      ),
    ]);
  },
};

/**
 * File utilities
 */
export const FileUtils = {
  generateFileName: (prefix: string = 'test', extension: string = 'csv'): string => {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    return `${prefix}-${timestamp}.${extension}`;
  },

  generateCsvContent: (headers: string[], rows: string[][]): string => {
    const csvLines = [headers.join(',')];
    rows.forEach(row => {
      csvLines.push(row.map(cell => `"${cell}"`).join(','));
    });
    return csvLines.join('\n');
  },

  getMimeType: (extension: string): string => {
    const mimeTypes: Record<string, string> = {
      'csv': 'text/csv',
      'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'json': 'application/json',
      'pdf': 'application/pdf',
      'txt': 'text/plain',
    };
    return mimeTypes[extension.toLowerCase()] || 'application/octet-stream';
  },
};

/**
 * CRM-specific test constants - Updated to match current database enums
 */
export const CRM_CONSTANTS = {
  // Updated to match current database enums
  ORGANIZATION_TYPES: ['customer', 'principal', 'distributor', 'prospect', 'vendor'] as const,
  ORGANIZATION_PRIORITIES: ['A', 'B', 'C', 'D'] as const,
  FOOD_SERVICE_SEGMENTS: [
    'Fine Dining', 'Fast Food', 'Fast Casual', 'Healthcare', 'Education', 
    'Corporate Catering', 'Hotel & Resort', 'Entertainment Venue', 
    'Retail Food Service', 'Government', 'Senior Living', 'Other'
  ] as const,
  
  CONTACT_ROLES: ['decision_maker', 'influencer', 'buyer', 'end_user', 'gatekeeper', 'champion'] as const,
  PURCHASE_INFLUENCE_LEVELS: ['low', 'moderate', 'high', 'very_high'] as const,
  DECISION_AUTHORITY_ROLES: ['decision_maker', 'recommender', 'influencer', 'user', 'gatekeeper'] as const,
  
  OPPORTUNITY_STAGES: [
    'New Lead', 'Initial Outreach', 'Sample/Visit Offered', 'Awaiting Response', 
    'Feedback Logged', 'Demo Scheduled', 'Closed - Won', 'Closed - Lost',
    'lead', 'qualified', 'proposal', 'negotiation', 'closed_won', 'closed_lost'
  ] as const,
  OPPORTUNITY_STATUSES: [
    'Active', 'On Hold', 'Closed - Won', 'Closed - Lost', 'Nurturing', 'Qualified',
    'active', 'on_hold', 'nurturing', 'qualified', 'closed_won', 'closed_lost'
  ] as const,
  
  INTERACTION_TYPES: [
    'call', 'email', 'meeting', 'demo', 'proposal', 'follow_up', 
    'trade_show', 'site_visit', 'contract_review'
  ] as const,
  
  PRODUCT_CATEGORIES: [
    'beverages', 'dairy', 'frozen', 'fresh_produce', 'meat_poultry', 'seafood',
    'dry_goods', 'spices_seasonings', 'baking_supplies', 'cleaning_supplies',
    'paper_products', 'equipment'
  ] as const,
  
  DEFAULT_TIMEOUTS: {
    SHORT: 5000,
    MEDIUM: 15000,
    LONG: 30000,
    EXTRA_LONG: 60000,
  },
  
  // Performance benchmarks for testing
  PERFORMANCE_THRESHOLDS: {
    SIMPLE_QUERY: 25, // ms
    JOIN_QUERY: 75, // ms
    DASHBOARD_QUERY: 150, // ms
    SEARCH_QUERY: 100, // ms
    PAGE_LOAD: 3000, // ms
    API_RESPONSE: 1000, // ms
  },
  
  // Test user IDs for consistent testing
  TEST_USER_IDS: {
    DEFAULT_USER: '00000000-0000-0000-0000-000000000001',
    DEFAULT_ORG: '00000000-0000-0000-0000-000000000002',
    DEFAULT_PRINCIPAL: '00000000-0000-0000-0000-000000000003',
    DEFAULT_OPPORTUNITY: '00000000-0000-0000-0000-000000000004',
    DEFAULT_CONTACT: '00000000-0000-0000-0000-000000000005',
  } as const,
  
  TEST_SELECTORS: {
    // Common data-testid selectors used across the application
    LOGIN_FORM: '[data-testid="login-form"]',
    NAVIGATION_MENU: '[data-testid="navigation-menu"]',
    ORGANIZATION_FORM: '[data-testid="organization-form"]',
    CONTACT_FORM: '[data-testid="contact-form"]',
    PRODUCT_FORM: '[data-testid="product-form"]',
    OPPORTUNITY_FORM: '[data-testid="opportunity-form"]',
    INTERACTION_FORM: '[data-testid="interaction-form"]',
    DATA_TABLE: '[data-testid="data-table"]',
    LOADING_SPINNER: '[data-testid="loading-spinner"]',
    ERROR_MESSAGE: '[data-testid="error-message"]',
    SUCCESS_MESSAGE: '[data-testid="success-message"]',
  },
} as const;

/**
 * Enhanced enum validation utilities with type safety
 */
export const EnumValidators = {
  organizationType: (value: string): value is Database['public']['Enums']['organization_type'] => {
    return CRM_CONSTANTS.ORGANIZATION_TYPES.includes(value as any)
  },
  
  contactRole: (value: string): value is Database['public']['Enums']['contact_role'] => {
    return CRM_CONSTANTS.CONTACT_ROLES.includes(value as any)
  },
  
  opportunityStage: (value: string): value is Database['public']['Enums']['opportunity_stage'] => {
    return CRM_CONSTANTS.OPPORTUNITY_STAGES.includes(value as any)
  },
  
  opportunityStatus: (value: string): value is Database['public']['Enums']['opportunity_status'] => {
    return CRM_CONSTANTS.OPPORTUNITY_STATUSES.includes(value as any)
  },
  
  interactionType: (value: string): value is Database['public']['Enums']['interaction_type'] => {
    return CRM_CONSTANTS.INTERACTION_TYPES.includes(value as any)
  },
  
  productCategory: (value: string): value is Database['public']['Enums']['product_category'] => {
    return CRM_CONSTANTS.PRODUCT_CATEGORIES.includes(value as any)
  },
  
  priorityLevel: (value: string): value is Database['public']['Enums']['priority_level'] => {
    return ['low', 'medium', 'high', 'critical'].includes(value)
  },
};

/**
 * Entity relationship validation utilities
 */
export const RelationshipValidators = {
  /**
   * Validate that required foreign key relationships are provided
   */
  validateContactRequirements: (data: ContactTestData): string[] => {
    const errors: string[] = []
    if (!data.organization_id) errors.push('Contact must have organization_id')
    if (!data.purchase_influence) errors.push('Contact must have purchase_influence level')
    if (!data.decision_authority) errors.push('Contact must have decision_authority role')
    return errors
  },
  
  validateProductRequirements: (data: ProductTestData): string[] => {
    const errors: string[] = []
    if (!data.principal_id) errors.push('Product must have principal_id')
    if (!data.category) errors.push('Product must have category')
    if (data.season_start && (data.season_start < 1 || data.season_start > 12)) {
      errors.push('season_start must be between 1-12')
    }
    if (data.season_end && (data.season_end < 1 || data.season_end > 12)) {
      errors.push('season_end must be between 1-12')
    }
    return errors
  },
  
  validateOpportunityRequirements: (data: OpportunityTestData): string[] => {
    const errors: string[] = []
    if (!data.organization_id) errors.push('Opportunity must have organization_id')
    if (data.probability && (data.probability < 0 || data.probability > 100)) {
      errors.push('Opportunity probability must be between 0-100')
    }
    if (data.estimated_value && data.estimated_value < 0) {
      errors.push('Opportunity estimated_value must be positive')
    }
    return errors
  },
  
  validateInteractionRequirements: (data: InteractionTestData): string[] => {
    const errors: string[] = []
    if (!data.opportunity_id) errors.push('Interaction must have opportunity_id')
    if (!data.subject || data.subject.trim() === '') errors.push('Interaction must have subject')
    if (!data.type) errors.push('Interaction must have type')
    return errors
  },
};

/**
 * Test data relationship builder - helps create related test entities
 */
export class TestDataBuilder {
  private entities: { [key: string]: any } = {}
  
  /**
   * Create organization and track for relationships
   */
  organization(name: string, data?: Partial<OrganizationTestData>): TestDataBuilder {
    this.entities[name] = TestData.organizations.valid()
    if (data) {
      this.entities[name] = { ...this.entities[name], ...data }
    }
    return this
  }
  
  /**
   * Create contact linked to organization
   */
  contact(name: string, orgName: string, data?: Partial<ContactTestData>): TestDataBuilder {
    if (!this.entities[orgName]) {
      throw new Error(`Organization '${orgName}' must be created before contact '${name}'`)
    }
    this.entities[name] = TestData.contacts.valid(this.entities[orgName].id)
    if (data) {
      this.entities[name] = { ...this.entities[name], ...data }
    }
    return this
  }
  
  /**
   * Create product linked to principal
   */
  product(name: string, principalName: string, data?: Partial<ProductTestData>): TestDataBuilder {
    if (!this.entities[principalName]) {
      throw new Error(`Principal '${principalName}' must be created before product '${name}'`)
    }
    this.entities[name] = TestData.products.valid(this.entities[principalName].id)
    if (data) {
      this.entities[name] = { ...this.entities[name], ...data }
    }
    return this
  }
  
  /**
   * Create opportunity linked to organization and optionally contact
   */
  opportunity(name: string, orgName: string, contactName?: string, data?: Partial<OpportunityTestData>): TestDataBuilder {
    if (!this.entities[orgName]) {
      throw new Error(`Organization '${orgName}' must be created before opportunity '${name}'`)
    }
    
    const contactId = contactName ? this.entities[contactName]?.id : undefined
    this.entities[name] = TestData.opportunities.valid(this.entities[orgName].id, contactId)
    
    if (data) {
      this.entities[name] = { ...this.entities[name], ...data }
    }
    return this
  }
  
  /**
   * Create interaction linked to opportunity
   */
  interaction(name: string, opportunityName: string, contactName?: string, orgName?: string, data?: Partial<InteractionTestData>): TestDataBuilder {
    if (!this.entities[opportunityName]) {
      throw new Error(`Opportunity '${opportunityName}' must be created before interaction '${name}'`)
    }
    
    const contactId = contactName ? this.entities[contactName]?.id : undefined
    const organizationId = orgName ? this.entities[orgName]?.id : undefined
    
    this.entities[name] = TestData.interactions.valid(this.entities[opportunityName].id, contactId, organizationId)
    
    if (data) {
      this.entities[name] = { ...this.entities[name], ...data }
    }
    return this
  }
  
  /**
   * Get built entity by name
   */
  get(name: string): any {
    return this.entities[name]
  }
  
  /**
   * Get all built entities
   */
  getAll(): { [key: string]: any } {
    return { ...this.entities }
  }
  
  /**
   * Reset builder
   */
  reset(): TestDataBuilder {
    this.entities = {}
    return this
  }
}
